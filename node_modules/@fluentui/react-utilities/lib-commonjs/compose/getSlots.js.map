{"version":3,"sources":["../../lib/compose/getSlots.js"],"sourcesContent":["import * as React from 'react';\nimport { omit } from '../utils/omit';\nimport { SLOT_RENDER_FUNCTION_SYMBOL } from './constants';\n/**\n * Given the state and an array of slot names, will break out `slots` and `slotProps`\n * collections.\n *\n * The root is derived from a mix of `components` props and `as` prop.\n *\n * Slots will render as null if they are rendered as primitives with undefined children.\n *\n * The slotProps will always omit the `as` prop within them, and for slots that are string\n * primitives, the props will be filtered according to the slot type by the type system.\n * For example, if the slot is rendered `as: 'a'`, the props will be filtered for acceptable\n * anchor props. Note that this is only enforced at build time by Typescript -- there is no\n * runtime code filtering props in this function.\n *\n * @param state - State including slot definitions\n * @returns An object containing the `slots` map and `slotProps` map.\n */\nexport function getSlots(state) {\n  const slots = {};\n  const slotProps = {};\n  const slotNames = Object.keys(state.components);\n  for (const slotName of slotNames) {\n    const [slot, props] = getSlot(state, slotName);\n    slots[slotName] = slot;\n    slotProps[slotName] = props;\n  }\n  return {\n    slots,\n    slotProps: slotProps\n  };\n}\nfunction getSlot(state, slotName) {\n  var _state_components, _state_components1;\n  const props = state[slotName];\n  if (props === undefined) {\n    return [null, undefined];\n  }\n  const {\n    children,\n    as: asProp,\n    [SLOT_RENDER_FUNCTION_SYMBOL]: renderFunction,\n    ...rest\n  } = props;\n  const slot = ((_state_components = state.components) === null || _state_components === void 0 ? void 0 : _state_components[slotName]) === undefined || typeof state.components[slotName] === 'string' ? asProp || ((_state_components1 = state.components) === null || _state_components1 === void 0 ? void 0 : _state_components1[slotName]) || 'div' : state.components[slotName];\n  if (renderFunction || typeof children === 'function') {\n    const render = renderFunction || children;\n    return [React.Fragment, {\n      children: render(slot, rest)\n    }];\n  }\n  const shouldOmitAsProp = typeof slot === 'string' && asProp;\n  const slotProps = shouldOmitAsProp ? omit(props, ['as']) : props;\n  return [slot, slotProps];\n}\n//# sourceMappingURL=getSlots.js.map"],"names":["getSlots","state","slots","slotProps","slotNames","Object","keys","components","slotName","slot","props","getSlot","_state_components","_state_components1","undefined","children","as","asProp","SLOT_RENDER_FUNCTION_SYMBOL","renderFunction","rest","render","React","Fragment","shouldOmitAsProp","omit"],"mappings":";;;;+BAoBgBA;;aAAAA;;;6DApBO;sBACF;2BACuB;AAkBrC,SAASA,SAASC,KAAK,EAAE;IAC9B,MAAMC,QAAQ,CAAC;IACf,MAAMC,YAAY,CAAC;IACnB,MAAMC,YAAYC,OAAOC,IAAI,CAACL,MAAMM,UAAU;IAC9C,KAAK,MAAMC,YAAYJ,UAAW;QAChC,MAAM,CAACK,MAAMC,MAAM,GAAGC,QAAQV,OAAOO;QACrCN,KAAK,CAACM,SAAS,GAAGC;QAClBN,SAAS,CAACK,SAAS,GAAGE;IACxB;IACA,OAAO;QACLR;QACAC,WAAWA;IACb;AACF;AACA,SAASQ,QAAQV,KAAK,EAAEO,QAAQ,EAAE;IAChC,IAAII,mBAAmBC;IACvB,MAAMH,QAAQT,KAAK,CAACO,SAAS;IAC7B,IAAIE,UAAUI,WAAW;QACvB,OAAO;YAAC,IAAI;YAAEA;SAAU;IAC1B,CAAC;IACD,MAAM,EACJC,SAAQ,EACRC,IAAIC,OAAM,EACV,CAACC,sCAA2B,CAAC,EAAEC,eAAc,EAC7C,GAAGC,MACJ,GAAGV;IACJ,MAAMD,OAAO,AAAC,CAAA,AAACG,CAAAA,oBAAoBX,MAAMM,UAAU,AAAD,MAAO,IAAI,IAAIK,sBAAsB,KAAK,IAAI,KAAK,IAAIA,iBAAiB,CAACJ,SAAS,AAAD,MAAOM,aAAa,OAAOb,MAAMM,UAAU,CAACC,SAAS,KAAK,WAAWS,UAAW,CAAA,AAACJ,CAAAA,qBAAqBZ,MAAMM,UAAU,AAAD,MAAO,IAAI,IAAIM,uBAAuB,KAAK,IAAI,KAAK,IAAIA,kBAAkB,CAACL,SAAS,AAAD,KAAM,QAAQP,MAAMM,UAAU,CAACC,SAAS;IACnX,IAAIW,kBAAkB,OAAOJ,aAAa,YAAY;QACpD,MAAMM,SAASF,kBAAkBJ;QACjC,OAAO;YAACO,OAAMC,QAAQ;YAAE;gBACtBR,UAAUM,OAAOZ,MAAMW;YACzB;SAAE;IACJ,CAAC;IACD,MAAMI,mBAAmB,OAAOf,SAAS,YAAYQ;IACrD,MAAMd,YAAYqB,mBAAmBC,IAAAA,UAAI,EAACf,OAAO;QAAC;KAAK,IAAIA,KAAK;IAChE,OAAO;QAACD;QAAMN;KAAU;AAC1B,EACA,oCAAoC"}