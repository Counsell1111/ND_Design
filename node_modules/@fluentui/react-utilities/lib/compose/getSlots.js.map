{"version":3,"names":["React","omit","SLOT_RENDER_FUNCTION_SYMBOL","getSlots","state","slots","slotProps","slotNames","Object","keys","components","slotName","slot","props","getSlot","_state_components","_state_components1","undefined","children","as","asProp","renderFunction","rest","render","Fragment","shouldOmitAsProp"],"sources":["../../src/compose/getSlots.ts"],"sourcesContent":["import * as React from 'react';\n\nimport { omit } from '../utils/omit';\nimport { SLOT_RENDER_FUNCTION_SYMBOL } from './constants';\nimport type {\n  AsIntrinsicElement,\n  ComponentState,\n  ExtractSlotProps,\n  SlotPropsRecord,\n  SlotRenderFunction,\n  UnionToIntersection,\n  UnknownSlotProps,\n} from './types';\n\nexport type Slots<S extends SlotPropsRecord> = {\n  [K in keyof S]: ExtractSlotProps<S[K]> extends AsIntrinsicElement<infer As>\n    ? // for slots with an `as` prop, the slot will be any one of the possible values of `as`\n      As\n    : ExtractSlotProps<S[K]> extends React.ComponentType<infer P>\n    ? React.ElementType<NonNullable<P>>\n    : React.ElementType<ExtractSlotProps<S[K]>>;\n};\n\nexport type ObjectSlotProps<S extends SlotPropsRecord> = {\n  [K in keyof S]-?: ExtractSlotProps<S[K]> extends AsIntrinsicElement<infer As>\n    ? // For intrinsic element types, return the intersection of all possible\n      // element's props, to be compatible with the As type returned by Slots<>\n      UnionToIntersection<JSX.IntrinsicElements[As]> // Slot<'div', 'span'>\n    : ExtractSlotProps<S[K]> extends React.ComponentType<infer P>\n    ? P // Slot<typeof Button>\n    : ExtractSlotProps<S[K]>; // Slot<ButtonProps>\n};\n\n/**\n * Given the state and an array of slot names, will break out `slots` and `slotProps`\n * collections.\n *\n * The root is derived from a mix of `components` props and `as` prop.\n *\n * Slots will render as null if they are rendered as primitives with undefined children.\n *\n * The slotProps will always omit the `as` prop within them, and for slots that are string\n * primitives, the props will be filtered according to the slot type by the type system.\n * For example, if the slot is rendered `as: 'a'`, the props will be filtered for acceptable\n * anchor props. Note that this is only enforced at build time by Typescript -- there is no\n * runtime code filtering props in this function.\n *\n * @param state - State including slot definitions\n * @returns An object containing the `slots` map and `slotProps` map.\n */\nexport function getSlots<R extends SlotPropsRecord>(\n  state: ComponentState<R>,\n): {\n  slots: Slots<R>;\n  slotProps: ObjectSlotProps<R>;\n} {\n  const slots = {} as Slots<R>;\n  const slotProps = {} as R;\n\n  const slotNames: (keyof R)[] = Object.keys(state.components);\n  for (const slotName of slotNames) {\n    const [slot, props] = getSlot(state, slotName);\n    slots[slotName] = slot as Slots<R>[typeof slotName];\n    slotProps[slotName] = props;\n  }\n  return { slots, slotProps: slotProps as unknown as ObjectSlotProps<R> };\n}\n\nfunction getSlot<R extends SlotPropsRecord, K extends keyof R>(\n  state: ComponentState<R>,\n  slotName: K,\n): readonly [React.ElementType<R[K]> | null, R[K]] {\n  const props = state[slotName];\n\n  if (props === undefined) {\n    return [null, undefined as R[K]];\n  }\n\n  const {\n    children,\n    as: asProp,\n    [SLOT_RENDER_FUNCTION_SYMBOL]: renderFunction,\n    ...rest\n  } = props as typeof props & { [SLOT_RENDER_FUNCTION_SYMBOL]?: SlotRenderFunction<R[K]> };\n\n  const slot = (\n    state.components?.[slotName] === undefined || typeof state.components[slotName] === 'string'\n      ? asProp || state.components?.[slotName] || 'div'\n      : state.components[slotName]\n  ) as React.ElementType<R[K]>;\n\n  if (renderFunction || typeof children === 'function') {\n    const render = renderFunction || (children as SlotRenderFunction<R[K]>);\n    return [\n      React.Fragment,\n      {\n        children: render(slot, rest as Omit<R[K], 'as'>),\n      } as unknown as R[K],\n    ];\n  }\n\n  const shouldOmitAsProp = typeof slot === 'string' && asProp;\n  const slotProps = (shouldOmitAsProp ? omit(props, ['as']) : (props as UnknownSlotProps)) as R[K];\n  return [slot, slotProps];\n}\n"],"mappings":"AAAA,YAAYA,KAAA,MAAW;AAEvB,SAASC,IAAI,QAAQ;AACrB,SAASC,2BAA2B,QAAQ;AA8B5C;;;;;;;;;;;;;;;;;AAiBA,OAAO,SAASC,SACdC,KAAwB,EAIxB;EACA,MAAMC,KAAA,GAAQ,CAAC;EACf,MAAMC,SAAA,GAAY,CAAC;EAEnB,MAAMC,SAAA,GAAyBC,MAAA,CAAOC,IAAI,CAACL,KAAA,CAAMM,UAAU;EAC3D,KAAK,MAAMC,QAAA,IAAYJ,SAAA,EAAW;IAChC,MAAM,CAACK,IAAA,EAAMC,KAAA,CAAM,GAAGC,OAAA,CAAQV,KAAA,EAAOO,QAAA;IACrCN,KAAK,CAACM,QAAA,CAAS,GAAGC,IAAA;IAClBN,SAAS,CAACK,QAAA,CAAS,GAAGE,KAAA;EACxB;EACA,OAAO;IAAER,KAAA;IAAOC,SAAA,EAAWA;EAA2C;AACxE;AAEA,SAASQ,QACPV,KAAwB,EACxBO,QAAW,EACsC;MAe/CI,iBAAA,EACcC,kBAAA;EAfhB,MAAMH,KAAA,GAAQT,KAAK,CAACO,QAAA,CAAS;EAE7B,IAAIE,KAAA,KAAUI,SAAA,EAAW;IACvB,OAAO,CAAC,IAAI,EAAEA,SAAA,CAAkB;EAClC;EAEA,MAAM;IACJC,QAAA;IACAC,EAAA,EAAIC,MAAA;IACJ,CAAClB,2BAAA,GAA8BmB,cAAA;IAC/B,GAAGC;EAAA,CACJ,GAAGT,KAAA;EAEJ,MAAMD,IAAA,GACJ,EAAAG,iBAAA,GAAAX,KAAA,CAAMM,UAAU,cAAhBK,iBAAA,uBAAAA,iBAAkB,CAACJ,QAAA,CAAS,MAAKM,SAAA,IAAa,OAAOb,KAAA,CAAMM,UAAU,CAACC,QAAA,CAAS,KAAK,WAChFS,MAAA,KAAU,CAAAJ,kBAAA,GAAAZ,KAAA,CAAMM,UAAU,cAAhBM,kBAAA,uBAAAA,kBAAkB,CAACL,QAAA,CAAS,CAAD,IAAK,QAC1CP,KAAA,CAAMM,UAAU,CAACC,QAAA,CAAS;EAGhC,IAAIU,cAAA,IAAkB,OAAOH,QAAA,KAAa,YAAY;IACpD,MAAMK,MAAA,GAASF,cAAA,IAAmBH,QAAA;IAClC,OAAO,CACLlB,KAAA,CAAMwB,QAAQ,EACd;MACEN,QAAA,EAAUK,MAAA,CAAOX,IAAA,EAAMU,IAAA;IACzB,EACD;EACH;EAEA,MAAMG,gBAAA,GAAmB,OAAOb,IAAA,KAAS,YAAYQ,MAAA;EACrD,MAAMd,SAAA,GAAamB,gBAAA,GAAmBxB,IAAA,CAAKY,KAAA,EAAO,CAAC,KAAK,IAAKA,KAA0B;EACvF,OAAO,CAACD,IAAA,EAAMN,SAAA,CAAU;AAC1B"}