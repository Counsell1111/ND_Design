import { ComponentProps } from '@fluentui/react-utilities';
import { ComponentState } from '@fluentui/react-utilities';
import type { Dispatch } from 'react';
import type { FC } from 'react';
import type { MutableRefObject } from 'react';
import * as React_2 from 'react';
import type { SetStateAction } from 'react';
import { Slot } from '@fluentui/react-utilities';
import type { SlotClassNames } from '@fluentui/react-utilities';

export declare const renderVirtualizer_unstable: (state: VirtualizerState) => JSX.Element;

export declare const renderVirtualizerScrollView_unstable: (state: VirtualizerScrollViewState) => JSX.Element;

/**
 * React hook that allows easy usage of the browser API IntersectionObserver within React
 * @param callback - A function called when the percentage of the target element is visible crosses a threshold.
 * @param options - An optional object which customizes the observer. If options isn't specified, the observer uses the
 * document's viewport as the root, with no margin, and a 0% threshold (meaning that even a one-pixel change is
 * enough to trigger a callback).
 * @returns An array containing a callback to update the list of Elements the observer should listen to, a callback to
 * update the init options of the IntersectionObserver and a ref to the IntersectionObserver instance itself.
 */
export declare const useIntersectionObserver: (callback: IntersectionObserverCallback, options?: IntersectionObserverInit | undefined) => {
    setObserverList: Dispatch<SetStateAction<Element[] | undefined>>;
    setObserverInit: Dispatch<SetStateAction<IntersectionObserverInit | undefined>>;
    observer: MutableRefObject<IntersectionObserver | undefined>;
};

/**
 * React hook that measures virtualized space based on a static size to ensure optimized virtualization length.
 */
export declare const useStaticVirtualizerMeasure: (virtualizerProps: VirtualizerMeasureProps) => {
    virtualizerLength: number;
    bufferItems: number;
    bufferSize: number;
    scrollRef: (instance: HTMLElement | HTMLDivElement | null) => void;
};

export declare function useVirtualizer_unstable(props: VirtualizerProps): VirtualizerState;

export declare function useVirtualizerScrollView_unstable(props: VirtualizerScrollViewProps): VirtualizerScrollViewState;

/**
 * Apply styling to the Virtualizer states
 */
export declare const useVirtualizerScrollViewStyles_unstable: (state: VirtualizerScrollViewState) => VirtualizerScrollViewState;

/**
 * Apply styling to the Virtualizer states
 */
export declare const useVirtualizerStyles_unstable: (state: VirtualizerState) => VirtualizerState;

/**
 * Virtualizer pseudo-component, this functional wrapper
 * provides a simple interface for reducing the total number
 * of elements rendered at one time in large lists.
 */
export declare const Virtualizer: FC<VirtualizerProps>;

export declare type VirtualizerChildRenderFunction = (index: number) => React_2.ReactNode;

export declare const virtualizerClassNames: SlotClassNames<VirtualizerSlots>;

declare type VirtualizerConfigProps = {
    /**
     * Child render function.
     * Iteratively called to return current virtualizer DOM children.
     * Will act as a row or column indexer depending on Virtualizer settings.
     * Can be used dynamically.
     */
    children: VirtualizerChildRenderFunction;
    /**
     * Default cell size to use if no custom callback provided.
     * If implementing `getItemSize` this should be the initial and ideally minimum cell size.
     */
    itemSize: number;
    /**
     * The total number of items to be virtualized.
     */
    numItems: number;
    /**
     * Number of children to render in the DOM during virtualization.
     * Constraints:
     * - Large enough that the items rendered in DOM cover the viewport
     *   and intersection observer buffers (buffersize) at both ends.
     */
    virtualizerLength: number;
    /**
     * Defaults to 1/4th of virtualizerLength.
     * Controls the number of elements rendered before the current index entering the virtualized viewport.
     * Constraints:
     * - Large enough to cover bufferSize (prevents buffers intersecting into the viewport during rest state).
     * - Small enough that the end buffer and end index (start index + virtualizerLength) is not within viewport at rest.
     */
    bufferItems?: number;
    /**
     * Defaults to half of bufferItems size (in pixels).
     * The length (in pixels) before the end/start DOM index where the virtualizer recalculation will be triggered.
     * Increasing this reduces whitespace on ultra-fast scroll, as additional elements
     * are buffered to appear while virtualization recalculates.
     * Constraints:
     * - At least 1px - although this will only trigger the recalculation after bookends (whitespace) enter viewport.
     * - BufferSize must be smaller than bufferItems pixel size, as it prevents bookends entering viewport at rest.
     */
    bufferSize?: number;
    /**
     * Enables users to override the intersectionObserverRoot.
     */
    scrollViewRef?: React_2.MutableRefObject<HTMLElement | null>;
    /**
     * The scroll direction
     * @default vertical
     */
    axis?: 'vertical' | 'horizontal';
    /**
     * Tells the virtualizer to measure in the reverse direction (for column-reverse order etc.)
     * This value should be flipped in RTL implementation (TBD whether automate RTL).
     */
    reversed?: boolean;
    /**
     * Callback for acquiring size of individual items
     * @param index - the index of the requested size's child
     */
    getItemSize?: (index: number) => number;
    /**
     * Notify users of index changes
     */
    onUpdateIndex?: (index: number, prevIndex: number) => void;
    /**
     * Allow users to intervene in index calculation changes
     */
    onCalculateIndex?: (newIndex: number) => number;
};

declare type VirtualizerConfigState = {
    /**
     * The current virtualized array of children to show in the DOM.
     */
    virtualizedChildren: React_2.ReactNode[];
    /**
     * The current start index for the virtualizer, all previous index's will be removed from DOM.
     */
    virtualizerStartIndex: number;
    /**
     * Current buffer height required at beginning of array.
     */
    afterBufferHeight: number;
    /**
     * Current buffer height required at end of array.
     */
    beforeBufferHeight: number;
    /**
     * The total current height of the scrollView/child content.
     */
    totalVirtualizerHeight: number;
    /**
     * The scroll direction
     * @default vertical
     */
    axis?: 'vertical' | 'horizontal';
    /**
     * Tells the virtualizer to measure in the reverse direction (for column-reverse order etc.)
     */
    reversed?: boolean;
    /**
     * Pixel size of intersection observers and how much they 'cross over' into the bufferItems index.
     * Minimum 1px.
     */
    bufferSize: number;
};

declare type VirtualizerMeasureProps = {
    defaultItemSize: number;
    direction?: 'vertical' | 'horizontal';
};

export declare type VirtualizerProps = ComponentProps<Partial<VirtualizerSlots>> & VirtualizerConfigProps;

/**
 * Virtualizer ScrollView
 */
export declare const VirtualizerScrollView: React_2.FC<VirtualizerScrollViewProps>;

export declare const virtualizerScrollViewClassNames: SlotClassNames<VirtualizerScrollViewSlots>;

export declare type VirtualizerScrollViewProps = ComponentProps<Partial<VirtualizerScrollViewSlots>> & Partial<Omit<VirtualizerConfigProps, 'itemSize' | 'numItems' | 'getItemSize' | 'children'>> & {
    /**
     * Virtualizer item size in pixels - static.
     * Axis: 'vertical' = Height
     * Axis: 'horizontal' = Width
     */
    itemSize: number;
    /**
     * The total number of items to be virtualized.
     */
    numItems: number;
    /**
     * Child render function.
     * Iteratively called to return current virtualizer DOM children.
     * Will act as a row or column indexer depending on Virtualizer settings.
     */
    children: VirtualizerChildRenderFunction;
};

export declare type VirtualizerScrollViewSlots = VirtualizerSlots & {
    /**
     * The root container that provides embedded scrolling.
     */
    container: NonNullable<Slot<'div'>>;
};

export declare type VirtualizerScrollViewState = ComponentState<VirtualizerScrollViewSlots> & VirtualizerConfigState;

export declare type VirtualizerSlots = {
    /**
     * The intersection observed 'before' element will detect when scrolling towards the beginning.
     */
    before: NonNullable<Slot<'div', 'td'>>;
    /**
     * A block place holding whitespace at the beginning of current DOM children.
     */
    beforeContainer: NonNullable<Slot<'div', 'tr'>>;
    /**
     * The intersection observed 'after' element will detect when scrolling towards the end.
     */
    after: NonNullable<Slot<'div', 'td'>>;
    /**
     * A block place holding whitespace after the end of current DOM children.
     */
    afterContainer: NonNullable<Slot<'div', 'tr'>>;
};

export declare type VirtualizerState = ComponentState<VirtualizerSlots> & VirtualizerConfigState;

export { }
