{"version":3,"names":["useIntersectionObserver","useEffect","useRef","useState","useCallback","useReducer","resolveShorthand","flushSync","useVirtualizer_unstable","props","itemSize","numItems","virtualizerLength","children","renderChild","getItemSize","bufferItems","Math","round","bufferSize","floor","scrollViewRef","axis","reversed","onUpdateIndex","onCalculateIndex","virtualizerStartIndex","setVirtualizerStartIndex","beforeElementRef","afterElementRef","childSizes","Array","childProgressiveSizes","childArray","forceUpdate","horizontal","populateSizeArrays","current","length","index","batchUpdateNewIndex","updateChildRows","updateCurrentItemSizes","setObserverList","entries","observer","measurementPos","bufferCount","latestEntry","sort","entry1","entry2","time","find","entry","intersectionRatio","target","calculateAfter","calculateTotalSize","abs","boundingClientRect","bottom","top","right","left","calculateBefore","max","startIndex","getIndexFromScrollPosition","bufferedIndex","maxIndex","newStartIndex","min","root","rootMargin","threshold","findIndexRecursive","scrollPos","lowIndex","highIndex","midpoint","iBefore","iAfter","indexValue","afterIndexValue","beforeIndexValue","getIndexFromSizeArray","lastItemIndex","remainingItems","newIndex","actualIndex","end","i","setBeforeRef","element","newList","push","setAfterRef","endIndex","didUpdate","newSize","prevSize","hasInitialized","initializeSizeArray","maxCompare","isFullyInitialized","components","before","after","beforeContainer","afterContainer","virtualizedChildren","required","defaultProps","ref","role","beforeBufferHeight","afterBufferHeight","totalVirtualizerHeight"],"sources":["../../../src/components/Virtualizer/useVirtualizer.ts"],"sourcesContent":["import { useIntersectionObserver } from '../../hooks/useIntersectionObserver';\nimport type { ReactNode } from 'react';\nimport { useEffect, useRef, useState, useCallback, useReducer } from 'react';\n\nimport type { VirtualizerProps, VirtualizerState } from './Virtualizer.types';\nimport { resolveShorthand } from '@fluentui/react-utilities';\nimport { flushSync } from 'react-dom';\n\nexport function useVirtualizer_unstable(props: VirtualizerProps): VirtualizerState {\n  const {\n    itemSize,\n    numItems,\n    virtualizerLength,\n    children: renderChild,\n    getItemSize,\n    bufferItems = Math.round(virtualizerLength / 4.0),\n    bufferSize = Math.floor(bufferItems / 2.0) * itemSize,\n    scrollViewRef,\n    axis = 'vertical',\n    reversed = false,\n    onUpdateIndex,\n    onCalculateIndex,\n  } = props;\n\n  // Tracks the initial item to start virtualizer at, -1 implies first render cycle\n  const [virtualizerStartIndex, setVirtualizerStartIndex] = useState<number>(-1);\n\n  // Store ref to before padding element\n  const beforeElementRef = useRef<Element | null>(null);\n\n  // Store ref to before padding element\n  const afterElementRef = useRef<Element | null>(null);\n\n  // We need to store an array to track dynamic sizes, we can use this to incrementally update changes\n  const childSizes = useRef<number[]>(new Array<number>(getItemSize ? numItems : 0));\n\n  /* We keep track of the progressive sizing/placement down the list,\n  this helps us skip re-calculations unless children/size changes */\n  const childProgressiveSizes = useRef<number[]>(new Array<number>(getItemSize ? numItems : 0));\n\n  // The internal tracking REF for child array (updates often).\n  const childArray = useRef<ReactNode[]>(new Array(virtualizerLength));\n\n  // We want to be methodical about updating the render with child reference array\n  const forceUpdate = useReducer(() => ({}), {})[1];\n\n  const horizontal = axis === 'horizontal';\n\n  const populateSizeArrays = () => {\n    if (!getItemSize) {\n      // Static sizes, never mind!\n      return;\n    }\n\n    if (numItems !== childSizes.current.length) {\n      childSizes.current = new Array<number>(numItems);\n    }\n\n    if (numItems !== childProgressiveSizes.current.length) {\n      childProgressiveSizes.current = new Array<number>(numItems);\n    }\n\n    for (let index = 0; index < numItems; index++) {\n      childSizes.current[index] = getItemSize(index);\n\n      if (index === 0) {\n        childProgressiveSizes.current[index] = childSizes.current[index];\n      } else {\n        childProgressiveSizes.current[index] = childProgressiveSizes.current[index - 1] + childSizes.current[index];\n      }\n    }\n  };\n\n  const batchUpdateNewIndex = (index: number) => {\n    // Local updates\n    onUpdateIndex?.(index, virtualizerStartIndex);\n    updateChildRows(index);\n    updateCurrentItemSizes(index);\n\n    // State setters\n    setVirtualizerStartIndex(index);\n  };\n\n  // Observe intersections of virtualized components\n  const { setObserverList } = useIntersectionObserver(\n    (entries: IntersectionObserverEntry[], observer: IntersectionObserver) => {\n      /* Sanity check - do we even need virtualization? */\n      if (virtualizerLength > numItems) {\n        if (virtualizerStartIndex !== 0) {\n          batchUpdateNewIndex(0);\n        }\n        // No-op\n        return;\n      }\n\n      /* IO initiates this function when needed (bookend entering view) */\n      let measurementPos = 0;\n      let bufferCount = bufferItems;\n\n      // Grab latest entry that is intersecting\n      const latestEntry =\n        entries.length === 1\n          ? entries[0]\n          : entries\n              .sort((entry1, entry2) => entry2.time - entry1.time)\n              .find(entry => {\n                return entry.intersectionRatio > 0;\n              });\n\n      if (!latestEntry) {\n        // If we don't find an intersecting area, ignore for now.\n        return;\n      }\n\n      if (latestEntry.target === afterElementRef.current) {\n        // We need to inverse the buffer count\n        bufferCount = virtualizerLength - bufferItems;\n        measurementPos = reversed ? calculateAfter() : calculateTotalSize() - calculateAfter();\n        if (!horizontal) {\n          if (reversed) {\n            // Scrolling 'up' and hit the after element below\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n          } else if (latestEntry.boundingClientRect.top < 0) {\n            // Scrolling 'down' and hit the after element above top: 0\n            measurementPos -= latestEntry.boundingClientRect.top;\n          }\n        } else {\n          if (reversed) {\n            // Scrolling 'left' and hit the after element\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n          } else if (latestEntry.boundingClientRect.left < 0) {\n            // Scrolling 'right' and hit the after element\n            measurementPos -= latestEntry.boundingClientRect.left;\n          }\n        }\n      } else if (latestEntry.target === beforeElementRef.current) {\n        measurementPos = reversed ? calculateTotalSize() - calculateBefore() : calculateBefore();\n        if (!horizontal) {\n          if (!reversed) {\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n          } else if (latestEntry.boundingClientRect.top < 0) {\n            // Scrolling 'down' in reverse order and hit the before element above top: 0\n            measurementPos -= latestEntry.boundingClientRect.top;\n          }\n        } else {\n          if (!reversed) {\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n          } else if (latestEntry.boundingClientRect.left < 0) {\n            // Scrolling 'left' and hit before element\n            measurementPos -= latestEntry.boundingClientRect.left;\n          }\n        }\n      }\n\n      if (reversed) {\n        // We're reversed, up is down, left is right, invert the scroll measure.\n        measurementPos = Math.max(calculateTotalSize() - Math.abs(measurementPos), 0);\n      }\n\n      // For now lets use hardcoded size to assess current element to paginate on\n      const startIndex = getIndexFromScrollPosition(measurementPos);\n      let bufferedIndex = Math.max(startIndex - bufferCount, 0);\n\n      if (onCalculateIndex) {\n        // User has chance to intervene/customize prior to render\n        // They may want to normalize this value.\n        bufferedIndex = onCalculateIndex(bufferedIndex);\n      }\n\n      // Safety limits\n      const maxIndex = Math.max(numItems - virtualizerLength, 0);\n      const newStartIndex = Math.min(Math.max(bufferedIndex, 0), maxIndex);\n\n      if (virtualizerStartIndex !== newStartIndex) {\n        // We flush sync this and perform an immediate state update\n        // due to virtualizerStartIndex invalidation.\n        flushSync(() => {\n          batchUpdateNewIndex(newStartIndex);\n        });\n      }\n    },\n    {\n      root: scrollViewRef ? scrollViewRef?.current : null,\n      rootMargin: '0px',\n      threshold: 0,\n    },\n  );\n\n  const findIndexRecursive = (scrollPos: number, lowIndex: number, highIndex: number): number => {\n    if (lowIndex > highIndex) {\n      // We shouldn't get here - but no-op the index if we do.\n      return virtualizerStartIndex;\n    }\n    const midpoint = Math.floor((lowIndex + highIndex) / 2);\n    const iBefore = Math.max(midpoint - 1, 0);\n    const iAfter = Math.min(midpoint + 1, childProgressiveSizes.current.length - 1);\n    const indexValue = childProgressiveSizes.current[midpoint];\n    const afterIndexValue = childProgressiveSizes.current[iAfter];\n    const beforeIndexValue = childProgressiveSizes.current[iBefore];\n    if (scrollPos <= afterIndexValue && scrollPos >= beforeIndexValue) {\n      /* We've found our index - if we are exactly matching before/after index that's ok,\n      better to reduce checks if it's right on the boundary. */\n      return midpoint;\n    }\n\n    if (indexValue > scrollPos) {\n      return findIndexRecursive(scrollPos, lowIndex, midpoint - 1);\n    } else {\n      return findIndexRecursive(scrollPos, midpoint + 1, highIndex);\n    }\n  };\n\n  const getIndexFromSizeArray = (scrollPos: number): number => {\n    /* Quick searches our progressive height array */\n    if (\n      scrollPos === 0 ||\n      childProgressiveSizes.current.length === 0 ||\n      scrollPos <= childProgressiveSizes.current[0]\n    ) {\n      // Check start\n      return 0;\n    }\n\n    if (scrollPos >= childProgressiveSizes.current[childProgressiveSizes.current.length - 1]) {\n      // Check end\n      return childProgressiveSizes.current.length - 1;\n    }\n\n    return findIndexRecursive(scrollPos, 0, childProgressiveSizes.current.length - 1);\n  };\n\n  const getIndexFromScrollPosition = (scrollPos: number) => {\n    if (!getItemSize) {\n      return Math.round(scrollPos / itemSize);\n    }\n\n    return getIndexFromSizeArray(scrollPos);\n  };\n\n  const calculateTotalSize = () => {\n    if (!getItemSize) {\n      return itemSize * numItems;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1];\n  };\n\n  const calculateBefore = () => {\n    if (!getItemSize) {\n      // The missing items from before virtualization starts height\n      return virtualizerStartIndex * itemSize;\n    }\n\n    if (virtualizerStartIndex <= 0) {\n      return 0;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[virtualizerStartIndex - 1];\n  };\n\n  const calculateAfter = () => {\n    if (numItems === 0) {\n      return 0;\n    }\n\n    const lastItemIndex = Math.min(virtualizerStartIndex + virtualizerLength, numItems - 1);\n    if (!getItemSize) {\n      // The missing items from after virtualization ends height\n      const remainingItems = numItems - lastItemIndex - 1;\n      return remainingItems * itemSize;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1] - childProgressiveSizes.current[lastItemIndex];\n  };\n\n  const updateChildRows = useCallback(\n    (newIndex: number) => {\n      if (numItems === 0) {\n        /* Nothing to virtualize */\n\n        return [];\n      }\n\n      if (childArray.current.length !== numItems) {\n        childArray.current = new Array(virtualizerLength);\n      }\n      const actualIndex = Math.max(newIndex, 0);\n      const end = Math.min(actualIndex + virtualizerLength, numItems);\n\n      for (let i = actualIndex; i < end; i++) {\n        childArray.current[i - actualIndex] = renderChild(i);\n      }\n    },\n    [numItems, renderChild, virtualizerLength],\n  );\n\n  const setBeforeRef = useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || beforeElementRef.current === element) {\n        return;\n      }\n      beforeElementRef.current = element;\n      const newList = [];\n\n      newList.push(beforeElementRef.current);\n\n      if (afterElementRef.current) {\n        newList.push(afterElementRef.current);\n      }\n\n      // Ensure we update array if before element changed\n      setObserverList(newList);\n    },\n    [setObserverList],\n  );\n\n  const setAfterRef = useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || afterElementRef.current === element) {\n        return;\n      }\n      afterElementRef.current = element;\n      const newList = [];\n\n      if (beforeElementRef.current) {\n        newList.push(beforeElementRef.current);\n      }\n\n      newList.push(afterElementRef.current);\n\n      // Ensure we update array if after element changed\n      setObserverList(newList);\n    },\n    [setObserverList],\n  );\n\n  const updateCurrentItemSizes = (newIndex: number) => {\n    if (!getItemSize) {\n      // Static sizes, not required.\n      return;\n    }\n    // We should always call our size function on index change (only for the items that will be rendered)\n    // This ensures we request the latest data for incoming items in case sizing has changed.\n    const endIndex = Math.min(newIndex + virtualizerLength, numItems);\n    const startIndex = Math.max(newIndex, 0);\n\n    let didUpdate = false;\n    for (let i = startIndex; i < endIndex; i++) {\n      const newSize = getItemSize(i);\n      if (newSize !== childSizes.current[i]) {\n        childSizes.current[i] = newSize;\n        didUpdate = true;\n      }\n    }\n\n    if (didUpdate) {\n      // Update our progressive size array\n      for (let i = startIndex; i < numItems; i++) {\n        const prevSize = i > 0 ? childProgressiveSizes.current[i - 1] : 0;\n        childProgressiveSizes.current[i] = prevSize + childSizes.current[i];\n      }\n    }\n  };\n\n  // Initialize the size array before first render.\n  const hasInitialized = useRef<boolean>(false);\n  const initializeSizeArray = () => {\n    if (hasInitialized.current === false) {\n      hasInitialized.current = true;\n      populateSizeArrays();\n    }\n  };\n\n  // Initialization on mount - update array index to 0 (ready state).\n  // Only fire on mount (no deps).\n  useEffect(() => {\n    if (virtualizerStartIndex < 0) {\n      batchUpdateNewIndex(0);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If the user passes in an updated renderChild function - update current children\n  useEffect(() => {\n    if (virtualizerStartIndex >= 0) {\n      updateChildRows(virtualizerStartIndex);\n      forceUpdate();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderChild, updateChildRows]);\n\n  // Ensure we have run through and updated the whole size list array at least once.\n  initializeSizeArray();\n\n  if (getItemSize && (numItems !== childSizes.current.length || numItems !== childProgressiveSizes.current.length)) {\n    // Child length mismatch, repopulate size arrays.\n    populateSizeArrays();\n  }\n\n  // Ensure we recalc if virtualizer length changes\n  const maxCompare = Math.min(virtualizerLength, numItems);\n  if (childArray.current.length !== maxCompare && virtualizerStartIndex + childArray.current.length < numItems) {\n    updateChildRows(virtualizerStartIndex);\n  }\n\n  const isFullyInitialized = hasInitialized.current && virtualizerStartIndex >= 0;\n  return {\n    components: {\n      before: 'div',\n      after: 'div',\n      beforeContainer: 'div',\n      afterContainer: 'div',\n    },\n    virtualizedChildren: childArray.current,\n    before: resolveShorthand(props.before, {\n      required: true,\n      defaultProps: {\n        ref: setBeforeRef,\n        role: 'none',\n      },\n    }),\n    after: resolveShorthand(props.after, {\n      required: true,\n      defaultProps: {\n        ref: setAfterRef,\n        role: 'none',\n      },\n    }),\n    beforeContainer: resolveShorthand(props.beforeContainer, {\n      required: true,\n      defaultProps: {\n        role: 'none',\n      },\n    }),\n    afterContainer: resolveShorthand(props.afterContainer, {\n      required: true,\n      defaultProps: {\n        role: 'none',\n      },\n    }),\n    beforeBufferHeight: isFullyInitialized ? calculateBefore() : 0,\n    afterBufferHeight: isFullyInitialized ? calculateAfter() : 0,\n    totalVirtualizerHeight: isFullyInitialized ? calculateTotalSize() : virtualizerLength * itemSize,\n    virtualizerStartIndex,\n    axis,\n    bufferSize,\n    reversed,\n  };\n}\n"],"mappings":"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"}