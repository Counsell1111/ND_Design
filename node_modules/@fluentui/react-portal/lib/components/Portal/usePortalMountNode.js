import * as React from 'react';
import { useThemeClassName_unstable as useThemeClassName, useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';
import { __styles, mergeClasses } from '@griffel/react';
import { useFocusVisible } from '@fluentui/react-tabster';
import { useDisposable } from 'use-disposable';
const useInsertionEffect = React['useInsertion' + 'Effect'];
const useStyles = /*#__PURE__*/__styles({
  root: {
    qhf8xq: "f10pi13n",
    Bj3rh1h: "f494woh"
  }
}, {
  d: [".f10pi13n{position:relative;}", ".f494woh{z-index:1000000;}"]
});
/**
 * Creates a new element on a "document.body" to mount portals.
 */
export const usePortalMountNode = options => {
  const {
    targetDocument,
    dir
  } = useFluent();
  const focusVisibleRef = useFocusVisible();
  const classes = useStyles();
  const themeClassName = useThemeClassName();
  const className = mergeClasses(themeClassName, classes.root, options.className);
  const element = useDisposable(() => {
    if (targetDocument === undefined || options.disabled) {
      return [null, () => null];
    }
    const newElement = targetDocument.createElement('div');
    targetDocument.body.appendChild(newElement);
    return [newElement, () => newElement.remove()];
  }, [targetDocument]);
  if (useInsertionEffect) {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useInsertionEffect(() => {
      if (!element) {
        return;
      }
      const classesToApply = className.split(' ').filter(Boolean);
      element.classList.add(...classesToApply);
      element.setAttribute('dir', dir);
      focusVisibleRef.current = element;
      return () => {
        element.classList.remove(...classesToApply);
        element.removeAttribute('dir');
      };
    }, [className, dir, element, focusVisibleRef]);
  } else {
    // This useMemo call is intentional for React 17
    // We don't want to re-create the portal element when its attributes change.
    // This also should not be done in an effect because, changing the value of css variables
    // after initial mount can trigger interesting CSS side effects like transitions.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useMemo(() => {
      if (!element) {
        return;
      }
      // Force replace all classes
      element.className = className;
      element.setAttribute('dir', dir);
      focusVisibleRef.current = element;
    }, [className, dir, element, focusVisibleRef]);
  }
  return element;
};
//# sourceMappingURL=usePortalMountNode.js.map