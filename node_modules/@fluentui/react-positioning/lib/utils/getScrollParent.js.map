{"version":3,"names":["getParentNode","node","nodeName","parentNode","host","getStyleComputedProperty","_node_ownerDocument","nodeType","window","ownerDocument","defaultView","getComputedStyle","getScrollParent","document","body","overflow","overflowX","overflowY","test","hasScrollParent","_scrollParentElement_ownerDocument","scrollParentElement"],"sources":["../../src/utils/getScrollParent.ts"],"sourcesContent":["/**\n * Returns the parent node or the host of the node argument.\n * @param node - DOM node.\n * @returns - parent DOM node.\n */\nexport const getParentNode = (node: HTMLElement): HTMLElement => {\n  if (node.nodeName === 'HTML') {\n    return node;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return node.parentNode || (node as any).host;\n};\n\n/**\n * Returns CSS styles of the given node.\n * @param node - DOM node.\n * @returns - CSS styles.\n */\nconst getStyleComputedProperty = (node: HTMLElement): Partial<CSSStyleDeclaration> => {\n  if (node.nodeType !== 1) {\n    return {};\n  }\n\n  const window = node.ownerDocument?.defaultView;\n  return window!.getComputedStyle(node, null);\n};\n\n/**\n * Returns the first scrollable parent of the given element.\n * @param node - DOM node.\n * @returns - the first scrollable parent.\n */\nexport const getScrollParent = (node: Document | HTMLElement | null): HTMLElement => {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  const parentNode = node && getParentNode(node as HTMLElement);\n  // eslint-disable-next-line\n  if (!parentNode) return document.body;\n\n  switch (parentNode.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return parentNode.ownerDocument!.body;\n    case '#document':\n      return (parentNode as unknown as Document).body;\n  }\n\n  // If any of the overflow props is defined for the node then we return it as the parent\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(parentNode);\n  if (/(auto|scroll|overlay)/.test(overflow! + overflowY! + overflowX)) {\n    return parentNode;\n  }\n\n  return getScrollParent(parentNode);\n};\n\nexport const hasScrollParent = (node: Document | HTMLElement | null): boolean => {\n  const scrollParentElement: HTMLElement = getScrollParent(node);\n  return scrollParentElement ? scrollParentElement !== scrollParentElement.ownerDocument?.body : false;\n};\n"],"mappings":"AAAA;;;;GAKA,OAAO,MAAMA,aAAA,GAAiBC,IAAA,IAAmC;EAC/D,IAAIA,IAAA,CAAKC,QAAQ,KAAK,QAAQ;IAC5B,OAAOD,IAAA;EACT;EACA;EACA,OAAOA,IAAA,CAAKE,UAAU,IAAIF,IAAC,CAAaG,IAAI;AAC9C;AAEA;;;;;AAKA,MAAMC,wBAAA,GAA4BJ,IAAA,IAAoD;MAKrEK,mBAAA;EAJf,IAAIL,IAAA,CAAKM,QAAQ,KAAK,GAAG;IACvB,OAAO,CAAC;EACV;EAEA,MAAMC,MAAA,GAAS,CAAAF,mBAAA,GAAAL,IAAA,CAAKQ,aAAa,cAAlBH,mBAAA,uBAAAA,mBAAA,CAAoBI,WAAW;EAC9C,OAAOF,MAAA,CAAQG,gBAAgB,CAACV,IAAA,EAAM,IAAI;AAC5C;AAEA;;;;;AAKA,OAAO,MAAMW,eAAA,GAAmBX,IAAA,IAAqD;EACnF;EACA,MAAME,UAAA,GAAaF,IAAA,IAAQD,aAAA,CAAcC,IAAA;EACzC;EACA,IAAI,CAACE,UAAA,EAAY,OAAOU,QAAA,CAASC,IAAI;EAErC,QAAQX,UAAA,CAAWD,QAAQ;IACzB,KAAK;IACL,KAAK;MACH,OAAOC,UAAA,CAAWM,aAAa,CAAEK,IAAI;IACvC,KAAK;MACH,OAAOX,UAAC,CAAmCW,IAAI;EAAA;EAGnD;EACA,MAAM;IAAEC,QAAA;IAAUC,SAAA;IAAWC;EAAS,CAAE,GAAGZ,wBAAA,CAAyBF,UAAA;EACpE,IAAI,wBAAwBe,IAAI,CAACH,QAAA,GAAYE,SAAA,GAAaD,SAAA,GAAY;IACpE,OAAOb,UAAA;EACT;EAEA,OAAOS,eAAA,CAAgBT,UAAA;AACzB;AAEA,OAAO,MAAMgB,eAAA,GAAmBlB,IAAA,IAAiD;MAE1BmB,kCAAA;EADrD,MAAMC,mBAAA,GAAmCT,eAAA,CAAgBX,IAAA;EACzD,OAAOoB,mBAAA,GAAsBA,mBAAA,MAAwB,CAAAD,kCAAA,GAAAC,mBAAA,CAAoBZ,aAAa,cAAjCW,kCAAA,uBAAAA,kCAAA,CAAmCN,IAAI,CAAD,GAAI,KAAK;AACtG"}