{"version":3,"names":["React","useControllableState","useFirstMount","useOptionCollection","useSelection","useComboboxBaseState","props","appearance","children","editable","inlinePopup","multiselect","onOpenChange","size","optionCollection","getOptionAtIndex","getOptionsMatchingValue","activeOption","setActiveOption","useState","focusVisible","setFocusVisible","hasFocus","setHasFocus","ignoreNextBlur","useRef","selectionState","selectedOptions","isFirstMount","controllableValue","setValue","state","value","initialState","undefined","useMemo","defaultValue","selectedOptionsText","optionValue","includes","map","option","text","join","open","setOpenState","defaultState","defaultOpen","setOpen","useCallback","event","newState","useEffect","length","selectedOption","v","pop"],"sources":["../../src/utils/useComboboxBaseState.ts"],"sourcesContent":["import * as React from 'react';\nimport { useControllableState, useFirstMount } from '@fluentui/react-utilities';\nimport { useOptionCollection } from '../utils/useOptionCollection';\nimport { OptionValue } from '../utils/OptionCollection.types';\nimport { useSelection } from '../utils/useSelection';\nimport type { ComboboxBaseProps, ComboboxBaseOpenEvents, ComboboxBaseState } from './ComboboxBase.types';\n\n/**\n * State shared between Combobox and Dropdown components\n */\nexport const useComboboxBaseState = (\n  props: ComboboxBaseProps & { children?: React.ReactNode; editable?: boolean },\n): ComboboxBaseState => {\n  const {\n    appearance = 'outline',\n    children,\n    editable = false,\n    inlinePopup = false,\n    multiselect,\n    onOpenChange,\n    size = 'medium',\n  } = props;\n\n  const optionCollection = useOptionCollection();\n  const { getOptionAtIndex, getOptionsMatchingValue } = optionCollection;\n\n  const [activeOption, setActiveOption] = React.useState<OptionValue | undefined>();\n\n  // track whether keyboard focus outline should be shown\n  // tabster/keyborg doesn't work here, since the actual keyboard focus target doesn't move\n  const [focusVisible, setFocusVisible] = React.useState(false);\n\n  // track focused state to conditionally render collapsed listbox\n  const [hasFocus, setHasFocus] = React.useState(false);\n\n  const ignoreNextBlur = React.useRef(false);\n\n  const selectionState = useSelection(props);\n  const { selectedOptions } = selectionState;\n\n  // calculate value based on props, internal value changes, and selected options\n  const isFirstMount = useFirstMount();\n  const [controllableValue, setValue] = useControllableState({\n    state: props.value,\n    initialState: undefined,\n  });\n\n  const value = React.useMemo(() => {\n    // don't compute the value if it is defined through props or setValue,\n    if (controllableValue !== undefined) {\n      return controllableValue;\n    }\n\n    // handle defaultValue here, so it is overridden by selection\n    if (isFirstMount && props.defaultValue !== undefined) {\n      return props.defaultValue;\n    }\n\n    const selectedOptionsText = getOptionsMatchingValue(optionValue => {\n      return selectedOptions.includes(optionValue);\n    }).map(option => option.text);\n\n    if (multiselect) {\n      // editable inputs should not display multiple selected options in the input as text\n      return editable ? '' : selectedOptionsText.join(', ');\n    }\n\n    return selectedOptionsText[0];\n\n    // do not change value after isFirstMount changes,\n    // we do not want to accidentally override defaultValue on a second render\n    // unless another value is intentionally set\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [controllableValue, editable, getOptionsMatchingValue, multiselect, props.defaultValue, selectedOptions]);\n\n  // Handle open state, which is shared with options in context\n  const [open, setOpenState] = useControllableState({\n    state: props.open,\n    defaultState: props.defaultOpen,\n    initialState: false,\n  });\n\n  const setOpen = React.useCallback(\n    (event: ComboboxBaseOpenEvents, newState: boolean) => {\n      onOpenChange?.(event, { open: newState });\n      setOpenState(newState);\n    },\n    [onOpenChange, setOpenState],\n  );\n\n  // update active option based on change in open state or children\n  React.useEffect(() => {\n    if (open && !activeOption) {\n      // if it is single-select and there is a selected option, start at the selected option\n      if (!multiselect && selectedOptions.length > 0) {\n        const selectedOption = getOptionsMatchingValue(v => v === selectedOptions[0]).pop();\n        selectedOption && setActiveOption(selectedOption);\n      }\n      // default to starting at the first option\n      else {\n        setActiveOption(getOptionAtIndex(0));\n      }\n    } else if (!open) {\n      // reset the active option when closing\n      setActiveOption(undefined);\n    }\n    // this should only be run in response to changes in the open state or children\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [open, children]);\n\n  return {\n    ...optionCollection,\n    ...selectionState,\n    activeOption,\n    appearance,\n    focusVisible,\n    hasFocus,\n    ignoreNextBlur,\n    inlinePopup,\n    open,\n    setActiveOption,\n    setFocusVisible,\n    setHasFocus,\n    setOpen,\n    setValue,\n    size,\n    value,\n  };\n};\n"],"mappings":"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"}