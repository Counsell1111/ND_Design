{"version":3,"names":["DEFAULT_WIDTH","DEFAULT_MIN_WIDTH","columnDefinitionsToState","columns","state","columnSizingOptions","updated","stateMap","Map","map","s","columnId","updatedState","column","existingColumnState","get","_columnSizingOptions_column_columnId","idealWidth","minWidth","padding","width","_columnSizingOptions_column_columnId1","defaultWidth","Math","max","length","find","col","getColumnById","c","getColumnByIndex","index","getTotalWidth","reduce","sum","getLength","getColumnWidth","_column_width","setColumnProperty","localState","property","value","currentColumn","updatedColumn","newState","acc","current","adjustColumnWidthsToFitContainer","containerWidth","totalWidth","difference","i","currentCol","colAdjustment","min","lastCol","j"],"sources":["../../src/utils/columnResizeUtils.ts"],"sourcesContent":["import { TableColumnDefinition, ColumnWidthState, TableColumnId, TableColumnSizingOptions } from '../hooks';\n\nconst DEFAULT_WIDTH = 150;\nconst DEFAULT_MIN_WIDTH = 100;\n\n/**\n * This function takes the column definitions and the curent ColumnWidthState and returns new state.\n *  - It uses existing state for existing columns.\n *  - It removes any state for columns no longer present.\n *  - It checks if any column has been replaced and returns updated state if so\n *  - It returns old state if no changes in the state have been made (so that react doesn't call effects)\n * @param columns\n * @param state\n * @returns\n */\n\nexport function columnDefinitionsToState<T>(\n  columns: TableColumnDefinition<T>[],\n  state: ColumnWidthState[] = [],\n  columnSizingOptions: TableColumnSizingOptions = {},\n): ColumnWidthState[] {\n  let updated = false;\n  const stateMap = new Map(state.map(s => [s.columnId, s]));\n\n  const updatedState = columns.map(column => {\n    const existingColumnState = stateMap.get(column.columnId);\n\n    if (existingColumnState) {\n      const {\n        idealWidth = existingColumnState.idealWidth,\n        minWidth = existingColumnState.minWidth,\n        padding = existingColumnState.padding,\n      } = columnSizingOptions[column.columnId] ?? {};\n\n      if (\n        idealWidth !== existingColumnState.idealWidth ||\n        minWidth !== existingColumnState.minWidth ||\n        padding !== existingColumnState.padding\n      ) {\n        updated = true;\n        return {\n          ...existingColumnState,\n          idealWidth,\n          width: idealWidth,\n          minWidth,\n          padding,\n        };\n      }\n      return existingColumnState;\n    }\n\n    const {\n      defaultWidth,\n      idealWidth = DEFAULT_WIDTH,\n      minWidth = DEFAULT_MIN_WIDTH,\n      padding,\n    } = columnSizingOptions[column.columnId] ?? {};\n\n    updated = true;\n    return {\n      columnId: column.columnId,\n      width: Math.max(defaultWidth ?? idealWidth, minWidth),\n      minWidth,\n      idealWidth: Math.max(defaultWidth ?? idealWidth, minWidth),\n      padding: padding ?? 16,\n    };\n  });\n\n  // If the length of the new state changed (column was added or removed) or any of\n  // the individual states has a new reference (column was replaced),\n  // we have to reset the column widths to their ideal width (because the column which was last may not be last now).\n  // Then the adjustColumnWidthsToFitContainer can do its job and properly stretch the last column.\n  if (updatedState.length !== state.length || updated) {\n    const column = updatedState.find(col => col.width > col.idealWidth);\n    if (column) {\n      column.width = column.idealWidth;\n    }\n\n    updated = true;\n  }\n\n  return updated ? updatedState : state;\n}\n\nexport function getColumnById(state: ColumnWidthState[], columnId: TableColumnId) {\n  return state.find(c => c.columnId === columnId);\n}\n\nexport function getColumnByIndex(state: ColumnWidthState[], index: number) {\n  return state[index];\n}\n\nexport function getTotalWidth(state: ColumnWidthState[]): number {\n  return state.reduce((sum, column) => sum + column.width + column.padding, 0);\n}\n\nexport function getLength(state: ColumnWidthState[]) {\n  return state.length;\n}\n\nexport function getColumnWidth(state: ColumnWidthState[], columnId: TableColumnId): number {\n  const column = getColumnById(state, columnId);\n  return column?.width ?? 0;\n}\n\n/**\n * This function takes the current state and returns an updated state, so that it can be set.\n * The reason for this is that we can update the state multiple times before commiting to render.\n * This is an optimization and also prevents flickering.\n * It also returns new copy of the state only if the value is different than the one currently in\n * the state, further preventing unnecessary updates.\n * @param localState\n * @param columnId\n * @param property\n * @param value\n * @returns\n */\nexport function setColumnProperty(\n  localState: ColumnWidthState[],\n  columnId: TableColumnId,\n  property: keyof ColumnWidthState,\n  value: number,\n) {\n  const currentColumn = getColumnById(localState, columnId);\n\n  if (!currentColumn || currentColumn?.[property] === value) {\n    return localState;\n  }\n\n  const updatedColumn = { ...currentColumn, [property]: value };\n\n  const newState = localState.reduce((acc, current) => {\n    if (current.columnId === updatedColumn.columnId) {\n      return [...acc, updatedColumn];\n    }\n    return [...acc, current];\n  }, [] as ColumnWidthState[]);\n\n  return newState;\n}\n\n/**\n * This function takes the state and container width and makes sure the each column in the state\n * is its optimal width, and that the columns\n * a) fit to the container\n * b) always fill the whole container\n * @param state\n * @param containerWidth\n * @returns\n */\nexport function adjustColumnWidthsToFitContainer(state: ColumnWidthState[], containerWidth: number) {\n  let newState = state;\n  const totalWidth = getTotalWidth(newState);\n\n  // The total width is smaller, we are expanding columns\n  if (totalWidth < containerWidth) {\n    let difference = containerWidth - totalWidth;\n    let i = 0;\n    // We start at the beginning and assign the columns their ideal width\n    while (i < newState.length && difference > 0) {\n      const currentCol = getColumnByIndex(newState, i);\n      const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);\n      newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width + colAdjustment);\n      difference -= colAdjustment;\n\n      // if there is still empty space, after all columns are their ideal sizes, assign it to the last column\n      if (i === newState.length - 1 && difference !== 0) {\n        const lastCol = getColumnByIndex(newState, i);\n        newState = setColumnProperty(newState, lastCol.columnId, 'width', lastCol.width + difference);\n      }\n\n      i++;\n    }\n  }\n\n  // The total width is larger than container, we need to squash the columns\n  else if (totalWidth >= containerWidth) {\n    let difference = totalWidth - containerWidth;\n    // We start with the last column\n    let j = newState.length - 1;\n    while (j >= 0 && difference > 0) {\n      const currentCol = getColumnByIndex(newState, j);\n      if (currentCol.width > currentCol.minWidth) {\n        const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);\n        difference -= colAdjustment;\n        newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width - colAdjustment);\n      }\n      j--;\n    }\n  }\n\n  return newState;\n}\n"],"mappings":"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"}