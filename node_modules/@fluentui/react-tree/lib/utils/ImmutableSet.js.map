{"version":3,"names":["emptyImmutableSet","createImmutableSet","iterable","internalSet","Set","dangerouslyCreateImmutableSet","size","add","value","nextSet","clear","delete","has","Symbol","iterator"],"sources":["../../src/utils/ImmutableSet.ts"],"sourcesContent":["export interface ImmutableSet<Value> {\n  /**\n   * The number of (unique) elements in a ImmutableSet.\n   */\n  readonly size: number;\n  /**\n   * Creates a new ImmutableSet containing all previous element plus the one provided as argument\n   * @param value - new value to be included in the new ImmutableSet instance\n   */\n  add(value: Value): ImmutableSet<Value>;\n  /**\n   * Returns a reference to ImmutableSet.emptySet\n   */\n  clear(): ImmutableSet<Value>;\n  /**\n   * Creates a new ImmutableSet with the original items and removes a specified value from the new ImmutableSet.\n   */\n  delete(value: Value): ImmutableSet<Value>;\n  /**\n   * @returns a boolean indicating whether an element with the specified value exists in the ImmutableSet or not.\n   */\n  has(value: Value): boolean;\n  /** Iterates over values in the ImmutableSet. */\n  [Symbol.iterator](): IterableIterator<Value>;\n}\n\nexport const emptyImmutableSet = createImmutableSet<never>();\n\n/**\n * properly creates an ImmutableSet instance from an iterable\n */\nexport function createImmutableSet<Value>(iterable?: Iterable<Value>): ImmutableSet<Value> {\n  const internalSet = new Set(iterable);\n  return dangerouslyCreateImmutableSet(internalSet);\n}\n/**\n * Avoid using *dangerouslyCreateImmutableSet*, since this method will expose internally used set, use  createImmutableSet instead,\n * @param internalSet - a set that is used internally to store values.\n */\nexport function dangerouslyCreateImmutableSet<Value>(internalSet: Set<Value>): ImmutableSet<Value> {\n  return {\n    size: internalSet.size,\n    add(value) {\n      const nextSet = new Set(internalSet);\n      nextSet.add(value);\n      return dangerouslyCreateImmutableSet(nextSet);\n    },\n    clear() {\n      return emptyImmutableSet;\n    },\n    delete(value) {\n      const nextSet = new Set(internalSet);\n      nextSet.delete(value);\n      return dangerouslyCreateImmutableSet(nextSet);\n    },\n    has(value) {\n      return internalSet.has(value);\n    },\n    [Symbol.iterator]() {\n      return internalSet[Symbol.iterator]();\n    },\n  };\n}\n"],"mappings":"AA0BA,OAAO,MAAMA,iBAAA,gBAAoBC,kBAAA;AAEjC;;;AAGA,OAAO,SAASA,mBAA0BC,QAA0B,EAAuB;EACzF,MAAMC,WAAA,GAAc,IAAIC,GAAA,CAAIF,QAAA;EAC5B,OAAOG,6BAAA,CAA8BF,WAAA;AACvC;AACA;;;;AAIA,OAAO,SAASE,8BAAqCF,WAAuB,EAAuB;EACjG,OAAO;IACLG,IAAA,EAAMH,WAAA,CAAYG,IAAI;IACtBC,IAAIC,KAAK,EAAE;MACT,MAAMC,OAAA,GAAU,IAAIL,GAAA,CAAID,WAAA;MACxBM,OAAA,CAAQF,GAAG,CAACC,KAAA;MACZ,OAAOH,6BAAA,CAA8BI,OAAA;IACvC;IACAC,MAAA,EAAQ;MACN,OAAOV,iBAAA;IACT;IACAW,OAAOH,KAAK,EAAE;MACZ,MAAMC,OAAA,GAAU,IAAIL,GAAA,CAAID,WAAA;MACxBM,OAAA,CAAQE,MAAM,CAACH,KAAA;MACf,OAAOH,6BAAA,CAA8BI,OAAA;IACvC;IACAG,IAAIJ,KAAK,EAAE;MACT,OAAOL,WAAA,CAAYS,GAAG,CAACJ,KAAA;IACzB;IACA,CAACK,MAAA,CAAOC,QAAQ,IAAI;MAClB,OAAOX,WAAW,CAACU,MAAA,CAAOC,QAAQ,CAAC;IACrC;EACF;AACF"}