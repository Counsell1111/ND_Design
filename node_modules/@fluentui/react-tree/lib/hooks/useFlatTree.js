import { useEventCallback } from '@fluentui/react-utilities';
import * as React from 'react';
import { createFlatTreeItems, VisibleFlatTreeItemGenerator } from '../utils/createFlatTreeItems';
import { treeDataTypes } from '../utils/tokens';
import { useFlatTreeNavigation } from './useFlatTreeNavigation';
import { useOpenItemsState } from './useOpenItemsState';
/**
 * this hook provides FlatTree API to manage all required mechanisms to convert a list of items into renderable TreeItems
 * in multiple scenarios including virtualization.
 *
 * !!A flat tree is an unofficial spec for tree!!
 *
 * It should be used on cases where more complex interactions with a Tree is required.
 * On simple scenarios it is advised to simply use a nested structure instead.
 *
 * @param flatTreeItemProps - a list of tree items
 * @param options - in case control over the internal openItems is required
 */
export function useFlatTree_unstable(flatTreeItemProps, options = {}) {
  const [openItems, updateOpenItems] = useOpenItemsState(options);
  const flatTreeItems = React.useMemo(() => createFlatTreeItems(flatTreeItemProps), [flatTreeItemProps]);
  const [navigate, navigationRef] = useFlatTreeNavigation(flatTreeItems);
  const handleOpenChange = useEventCallback((event, data) => {
    var _options_onOpenChange;
    (_options_onOpenChange = options.onOpenChange) === null || _options_onOpenChange === void 0 ? void 0 : _options_onOpenChange.call(options, event, data);
    if (!event.isDefaultPrevented()) {
      updateOpenItems(data);
    }
    event.preventDefault();
  });
  const handleNavigation = useEventCallback((event, data) => {
    var _options_onNavigation_unstable;
    (_options_onNavigation_unstable = options.onNavigation_unstable) === null || _options_onNavigation_unstable === void 0 ? void 0 : _options_onNavigation_unstable.call(options, event, data);
    if (!event.isDefaultPrevented()) {
      navigate(data);
    }
    event.preventDefault();
  });
  const getNextNavigableItem = useEventCallback((visibleItems, data) => {
    const item = flatTreeItems.get(data.target.id);
    if (item) {
      switch (data.type) {
        case treeDataTypes.typeAhead:
          return item;
        case treeDataTypes.arrowLeft:
          return flatTreeItems.get(item.parentId);
        case treeDataTypes.arrowRight:
          return visibleItems[item.index + 1];
        case treeDataTypes.end:
          return visibleItems[visibleItems.length - 1];
        case treeDataTypes.home:
          return visibleItems[0];
        case treeDataTypes.arrowDown:
          return visibleItems[item.index + 1];
        case treeDataTypes.arrowUp:
          return visibleItems[item.index - 1];
      }
    }
  });
  const getTreeProps = React.useCallback(() => ({
    ref: navigationRef,
    openItems,
    onOpenChange: handleOpenChange,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    onNavigation_unstable: handleNavigation
  }),
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [openItems]);
  const items = React.useCallback(() => VisibleFlatTreeItemGenerator(openItems, flatTreeItems), [openItems, flatTreeItems]);
  return React.useMemo(() => ({
    navigate,
    getTreeProps,
    getNextNavigableItem,
    items
  }), [navigate, getTreeProps, getNextNavigableItem, items]);
}
//# sourceMappingURL=useFlatTree.js.map